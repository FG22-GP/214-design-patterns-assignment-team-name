# Project Description:
A 2D side scrolling platformer with animations for the player and win-lose conditions. 

[See screenshot 1 here](https://i.imgur.com/lUlvz5S.png)

[See screenshot 2 here](https://i.imgur.com/j3okxCT.png)

[See video here](https://i.imgur.com/CjsuQmj.gifv)

# Design Patterns:
- Command pattern: In this pattern you encapsulate a function call in a wrapper object (the command). Another commanding class then has a bunch of references to different commands it will run whenever needed. This pattern was implemented for our player inputs. There is a Command class which has a virtual execute function that subclasses will override to do different things. For example, a JumpCommand subclass would override the execute function to do something like player->jump(). The Input class holds a bunch of these input commands and calls their execute function whenever certain buttons are pressed. The reason we chose this pattern is because it makes it very easy to add new functionality or change the key bindings to existing inputs. This system also creates a level of separation between the player class and the input class, meaning the player only holds logic for how to react to inputs, and doesn't need to know how the actual inputs are gotten from the system (a little bit of Bridge pattern). 

- Singleton pattern: This pattern makes sure that there is only ever one single instance of a given class, and also makes that class accessible from anywhere without needing a reference to it. This is implemented for our Player class and Engine class. The Engine class takes care of rendering sprites and text, so there will never be a reason to have more than one of it on a singleplayer game. The Engine being accessible anywhere also makes it easy for other classes to, for example, create a sprite when they need one by just doing something like this Engine::GetInstance.GetSprite(). The same reasons go for the Player class. For example, the input commands won't need a reference to the player to work, and can just do something like this Player::getInstance().Jump(). This makes creating certain functionality much easier, but also comes at the downside of not being able to easily change the game to include multiple players. 

- Facade pattern: This pattern serves to hide a lot of complicated code behind a simple useable facade. This pattern can be found in multiple places in this project, like the Animator.UpdateSprite function, which can be called whenever the user class thinks its animation should update. This function will check the animator's current animation state, transition to a different animation if the transition condition is met, and also increments the current animation's frame at a given time interval. This pattern is also in the PlayerAnimator class that is a subclass of Animator. In its constructor, the PlayerAnimator class initializes all animations the player can do and all possible transitions between each animation state, while only requiring PlayerAnimator{} to be written in the player's class. This pattern is also used in some Engine functions, such as GetSprite(), which returns a Sprite pointer. This function will make sure that only one of each texture is loaded at any time, pooling them so that they can be reused if it gets asked for the same texture multiple times. We chose this pattern because of its ability to make complex code that would be needed many times easier to use. 

- State pattern: The state pattern is basically implementing a finite state machine where the machine can only ever be in one state at a time and can move between states depending on the current state's transitions. This pattern is implemented in the Animator class. The Animator has an array of AnimationStates which are defined by an Animation and a list of transitions to other AnimationStates. The transitions are function variables that return bools for whether the transition should be triggered or not. This can for example look like this: Animation1 has a transition to Animation2 when player->isGrounded == true. Animation2 can then have its own transition to Animation3 when player->velocity > 0, or one back to Animation1 when player->isGrounded == false. Animation3 can only ever play from Animation2. We chose to implement this pattern because recreating the previous example without states would mean that there would need to be a mess of "if else if else" statements to figure out which animation the animator is allowed to do. This is especially bad if it's an animation that should only be triggered after another animation (for example, the fall animation should only run after the jump animation reaches its peak). This way, defining transitions is much easier and doesn't consume as much time, and transition conditions are much shorter (for example, if I'm doing a jump animation, I already know I'm not grounded. The only possible next animation is fall, so I only need to check if velocity went under 0 instead of also having to check if I'm not grounded). It also means that the user class doesn't need to worry about checking whether it should switch the animation or not, as once the transitions are defined, the Animator will take care of the rest. 

[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/XUCedPox)
# marczaku-214-design-patterns-assignment
